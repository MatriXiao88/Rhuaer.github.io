---
layout:     post
title:      渐变色角度转成Echarts的坐标值
date:       2018-04-01
summary:    渐变色，echarts
categories: jekyll pixyll
---

做echarts图表的时候，渐变色方向的定义是通过坐标值，如以下示例，渐变色方向是垂直向下：

``` javascript
color: {
    type: 'linear',
    x: 0,
    y: 0,
    x2: 0,
    y2: 1,
    colorStops: [{
        offset: 0, color: 'red' // 0% 处的颜色
    }, {
        offset: 1, color: 'blue' // 100% 处的颜色
    }],
}
```

其中x、y是起始点坐标值，x2、y2是终止点坐标值。

从上述示例中可以看出：**echarts渐变色方向的x坐标轴是水平向左，y坐标轴是垂直向下的。**

但是，我们从设计师那里拿到的设计稿中标注的渐变色方向，通常是用角度表示的。

所以这里就需要将设计稿的角度转换成对应的坐标值，做到设计稿的渐变方向效果和echarts的实现效果一致。如果项目做的图标就那么一两个需要用到渐变色的，那么对照着设计稿的效果调整一下坐标值，试验多几次，就可以找到规律。

但在项目中，如果使用渐变色的图表比较多，而且渐变方向不一定是0°、90°、180°、270°的话，就需要计算一番，如果是经多人维护，后来的人可能还需要翻翻echarts文档，也来做一次实验才知道其中的规律。

为了解决上面麻烦的地方，下面写了个方法，可以一次性把设计稿的渐变色角度转换成echarts中对应的坐标值。

## 开始之前

首先，我们这里定义的角度，初始方向是垂直向上的，然后分两种情况来描述角度值。

- 顺时针为正方向

- 逆时针为正方向

实际工作中的设计稿，都有可能使用其中的一种描述渐变色角度值。这里首先来说顺时针为正方向的这种，因为这种是个人唯一按照初中数学逻辑推导出来的，逆时针方向的则是通过直觉推导出来的。

## 顺时针为正方向的角度转换

``` javascript
function convert(angle) {
  let result = '';
  if (angle >= 0) {
    const radian = angle / 180 * Math.PI;
    let x2 = Math.sin(radian),
        y2 = Math.cos(radian),
        x = 0,
        y = 0;
    y2 *= -1; // 其实这里是相当于做了一次矩阵乘法multiply([x2, y2], [[1, 0], [0, -1]]), 一个1x2矩阵和2x2矩阵相乘。这个矩阵比较特殊，有效操作只有y2值，所以代码做了简化
    if (x2 < 0) {//有小于0的，则进行平移
      x = x2 * -1;
      x2 = 0;
    }
    if (y2 < 0) {
      y = y2 * -1;
      y2 = 0;
    }
    result = `(${x},${y}), (${x2},${y2})`;
  }
}
```

这里涉及到奇淫技巧的地方有：

- 容易想到通过三角函数来计算坐标值，而这里使用三角函数来计算终止点的坐标值，而且`x2`是通过正弦函数计算，`y2`是通过余弦函数计算。这里的原因是设计稿的0°是垂直向上的，但平面坐标系中的0°是水平向右的，相当于将x轴正向旋转了90°。然后通过下面的公式，就知道为什么会出现刚才的交换了。

  $$\sin({\pi \over 2} + α ) = \cosα$$
  $$\cos({\pi \over 2} + α ) = \sinα$$

- `y2 *= -1;`，这个为什么这么做上面注释已经写了。

- 坐标平移。因为echarts中渐变色的方向坐标值，其中每个分量值的区间必须是[0, 1]，所以对于小于0的分量值，做一下坐标平移就ok，初中数学告诉我们，坐标平移是不会影响向量的方向的。

## 逆时针为正方向的角度转换

逆时针为正方向的角度转换，这里面的转换逻辑依据，暂时是没有的，因为当时只是把角度方向和结果坐标值一列出来，然后直觉中就feel到一种转换关系了。代码如下：

``` javascript
//角度统一归算到0-360度。
const positiveDegree = (360 + degree) % 360;
//计算角度对应的弧度
const positiveRadian = positiveDegree / 180 * Math.PI;
let x = Math.sin(positiveRadian),
    y = Math.cos(positiveRadian),
    x2 = 0,
    y2 = 0;
//如果计算坐标数值小于0，则平移相应的坐标数值
if (x < 0) {
  x2 = Math.abs(x);
  x = 0;
}
if (y < 0) {
  y2 = Math.abs(y);
  y = 0;
}
```

这里和上面有一点相反，就是将三角函数的计算值作为渐变色方向坐标值的起点值，然后再根据情况做一下坐标值平移，就一切ok了。

## 最后

一个感觉就是学好数学，心里才有点底，另外各种方向变换的，仿射矩阵还是应该多了解，多应用，例如这里需要将坐标值取反，应该如何设置仿射矩阵呢。

问题并不难，处理方法也简单，纯粹是玩玩~



